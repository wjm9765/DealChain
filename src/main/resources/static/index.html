<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <title>WebSocket STOMP Test</title>
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
</head>
<body>
<h1>WebSocket STOMP Test</h1>
<div>
    <label for="tokenInput">JWT Token:</label>
    <input type="text" id="tokenInput" placeholder="Enter JWT token here" style="width:400px;" />
    <button onclick="connect()">Connect</button>
    <!-- Disconnect 버튼은 자동 퇴장 후 disconnect하도록 요구되어 제거 -->
</div>
<div>
    <label for="roomIdInput">Room ID:</label>
    <input type="text" id="roomIdInput" value="4b504d2c-565c-4640-937c-fe9732510ca5" />
    <button onclick="subscribeToRoom()">Subscribe</button>
    <button onclick="unsubscribeFromRoom()">Unsubscribe</button>
</div>
<!-- 새로 추가: 개인 알림(Private Notifications) 구독 UI -->
<div style="margin-top:8px;">
    <button onclick="subscribeNotifications()">Subscribe Notifications</button>
    <button onclick="unsubscribeNotifications()">Unsubscribe Notifications</button>
    <a id="manualOpenNotif" href="#" target="_blank" style="margin-left:8px; display:none">수동으로 콘솔 열기</a>
</div>
<div>
    <label for="senderIdInput">Sender ID:</label>
    <input type="text" id="senderIdInput" value="10" />
    <br />
    <label for="messageInput">Message:</label>
    <input type="text" id="messageInput" placeholder="Enter message here" />
    <button onclick="sendMessage()">Send Message (TALK)</button>
    <button onclick="enterRoom()">Enter (ENTER)</button>
    <button onclick="leaveRoom()">Leave (LEAVE & Disconnect)</button>
</div>
<h2>Received Messages:</h2>
<div id="messages" style="border: 1px solid #ccc; height: 300px; overflow-y: scroll; padding: 10px;"></div>

<!-- 새로 추가: 개인 알림 표시 영역 (채팅 메시지와 분리) -->
<h2>Personal Notifications:</h2>
<div id="notifications" style="border: 1px solid #f39c12; height: 150px; overflow-y: auto; padding: 10px; background:#fff8e1;"></div>

<script>
    // 서버 도메인 / WebSocket 엔드포인트
    const SERVER_WS_BASE = 'http://dealchain2-env.eba-hjicm52y.ap-northeast-2.elasticbeanstalk.com';
    const AWS_CONSOLE_NOTIF_URL = 'https://ap-northeast-2.console.aws.amazon.com/elasticbeanstalk/home?region=ap-northeast-2#/application/overview?applicationName=dealchain/sub~';

    let stompClient = null; // 기존 채팅용 클라이언트
    let currentSubscription = null;

    // 별도 알림용 STOMP 클라이언트 및 서브스
    let notifClient = null;
    let notifSubscription = null;

    let notificationSubscription = null; // 기존 변수 kept for compatibility
    const messagesDiv = document.getElementById('messages');
    const notificationsDiv = document.getElementById('notifications');
    const manualOpenNotif = document.getElementById('manualOpenNotif');

    function log(message) {
        console.log(message);
        const p = document.createElement('p');
        p.textContent = `[LOG] ${message}`;
        messagesDiv.appendChild(p);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function connect() {
        if (stompClient && stompClient.active) {
            log("Already connected.");
            return;
        }

        const token = document.getElementById('tokenInput').value?.trim();
        if (!token) {
            log('No token provided. Please enter JWT token before connecting.');
            return;
        }

        log("Attempting to connect...");

        const connectHeaders = { Authorization: 'Bearer ' + token };

        stompClient = new StompJs.Client({
            webSocketFactory: () => new SockJS(`${SERVER_WS_BASE}/ws`),
            connectHeaders: connectHeaders,
            debug: function (str) { log("STOMP Debug: " + str); },
            reconnectDelay: 5000,
            heartbeatIncoming: 4000,
            heartbeatOutgoing: 4000,
            onConnect: (frame) => { log('Connected: ' + frame); },
            onStompError: (frame) => { log('Broker reported error: ' + frame.headers['message']); log('Additional details: ' + frame.body); },
            onWebSocketError: (error) => { log('WebSocket Error: ' + error); },
            onDisconnect: () => { log('Disconnected'); stompClient = null; currentSubscription = null; }
        });

        stompClient.activate();
    }

    function disconnect() {
        if (stompClient && stompClient.active) { stompClient.deactivate(); } else { log("Not connected."); }
    }

    function subscribeToRoom() {
        if (!stompClient || !stompClient.active) { log("Connect first!"); return; }
        if (currentSubscription) { log("Already subscribed. Unsubscribe first if you want to change the room."); return; }
        const roomId = document.getElementById('roomIdInput').value; if (!roomId) { log("Enter Room ID!"); return; }
        const destination = `/sub/chat/room/${roomId}`;
        log(`Attempting to subscribe to ${destination}`);
        try {
            currentSubscription = stompClient.subscribe(destination, (message) => {
                log(`Received message: ${message.body}`);
                try {
                    const msgData = JSON.parse(message.body);
                    const wrapper = document.createElement('div');
                    const strong = document.createElement('strong');
                    strong.textContent = (msgData.senderId || 'System') + ':';
                    const text = document.createElement('span');
                    let content = msgData.message;
                    try { if (typeof content === 'string' && /%[0-9A-Fa-f]{2}/.test(content)) { content = decodeURIComponent(content); } } catch (e) {}
                    text.textContent = ' ' + (content ?? '');
                    wrapper.appendChild(strong); wrapper.appendChild(text); messagesDiv.appendChild(wrapper); messagesDiv.scrollTop = messagesDiv.scrollHeight;
                } catch(e) { log(`Error parsing message: ${e}`); }
            });
            log(`Subscribed to ${destination} with ID: ${currentSubscription.id}`);
        } catch (error) { log(`Subscription error: ${error}`); }
    }

    function unsubscribeFromRoom() { if (!currentSubscription) { log("Not currently subscribed to any room."); return; } try { currentSubscription.unsubscribe(); log(`Unsubscribed from ID: ${currentSubscription.id}`); currentSubscription = null; } catch (error) { log(`Unsubscription error: ${error}`); } }

    function sendMessage() {
        if (!stompClient || !stompClient.active) { log("Connect first!"); return; }
        if (!currentSubscription) { log("Subscribe to a room first!"); return; }
        const roomId = document.getElementById('roomIdInput').value;
        const senderId = Number(document.getElementById('senderIdInput').value);
        const messageContent = document.getElementById('messageInput').value;
        if (Number.isNaN(senderId) || !messageContent.trim()) { log("Enter Sender ID and Message!"); return; }
        const messageToSend = { type: "TALK", roomId: roomId, senderId: senderId, message: messageContent };
        const destination = "/pub/chat/message";
        try { stompClient.publish({ destination: destination, body: JSON.stringify(messageToSend) }); log(`Message sent to ${destination}: ${JSON.stringify(messageToSend)}`); document.getElementById('messageInput').value = ''; } catch (error) { log(`Send error: ${error}`); }
    }

    function enterRoom() { if (!stompClient || !stompClient.active) { log("Connect first!"); return; } const roomId = document.getElementById('roomIdInput').value; const senderId = Number(document.getElementById('senderIdInput').value); if (!roomId || Number.isNaN(senderId)) { log("Enter Room ID and Sender ID before entering."); return; } const messageToSend = { type: "ENTER", roomId: roomId, senderId: senderId, message: `${senderId}님이 입장합니다.` }; const destination = "/pub/chat/message"; try { stompClient.publish({ destination: destination, body: JSON.stringify(messageToSend) }); log(`ENTER sent: ${JSON.stringify(messageToSend)}`); } catch (error) { log(`ENTER send error: ${error}`); } }

    function leaveRoom() { if (!stompClient || !stompClient.active) { log("Connect first!"); return; } const roomId = document.getElementById('roomIdInput').value; const senderId = Number(document.getElementById('senderIdInput').value); if (!roomId || Number.isNaN(senderId)) { log("Enter Room ID and Sender ID before leaving."); return; } const messageToSend = { type: "LEAVE", roomId: roomId, senderId: senderId, message: `${senderId}님이 퇴장합니다.` }; const destination = "/pub/chat/message"; try { stompClient.publish({ destination: destination, body: JSON.stringify(messageToSend) }); log(`LEAVE sent: ${JSON.stringify(messageToSend)}. Will disconnect shortly.`); setTimeout(() => { try { disconnect(); } catch (e) { log('Error during disconnect: ' + e); } }, 200); } catch (error) { log(`LEAVE send error: ${error}`); } }

    // --------------------------------------------------
    // 개인 알림: 원격 도메인에 직접 연결하여 /user/queue/notifications 구독
    // --------------------------------------------------
    function subscribeNotifications() {
        if (notificationSubscription || notifSubscription) { log('Already subscribed to personal notifications.'); return; }

        const fullNotifDestination = `${SERVER_WS_BASE}/user/queue/notifications`;
        log(`Will subscribe to destination (no navigation): ${fullNotifDestination}`);

        // 1) 기존 연결이 있으면 그걸로 먼저 /user/queue/notifications 구독 (로그에 전체 주소 표기)
        try {
            if (stompClient && stompClient.active) {
                log(`Subscribing (main client) to ${fullNotifDestination}`);
                notificationSubscription = stompClient.subscribe('/user/queue/notifications', (message) => {
                    log(`Notification(received via main client): ${message.body}`);
                    try {
                        const payload = JSON.parse(message.body);
                        const wrapper = document.createElement('div');
                        const strong = document.createElement('strong');
                        strong.textContent = `[${new Date().toLocaleTimeString()}] ${payload.type || 'NOTI'}:`;
                        const txt = document.createElement('span');
                        let msg = payload.message ?? message.body ?? '';
                        try { if (typeof msg === 'string' && /%[0-9A-Fa-f]{2}/.test(msg)) msg = decodeURIComponent(msg); } catch(e){}
                        txt.textContent = ' ' + msg;
                        wrapper.appendChild(strong);
                        wrapper.appendChild(txt);
                        notificationsDiv.appendChild(wrapper);
                        notificationsDiv.scrollTop = notificationsDiv.scrollHeight;
                    } catch(e) {
                        const p = document.createElement('p'); p.textContent = `[RAW] ${message.body}`; notificationsDiv.appendChild(p); notificationsDiv.scrollTop = notificationsDiv.scrollHeight;
                    }
                });
                log('Subscribed to /user/queue/notifications via main client');
            }
        } catch(e) { log('Main client subscription failed: ' + e); }

        // 2) 별도 알림용 클라이언트로 원격 서버에 직접 연결해서 구독
        const token = document.getElementById('tokenInput').value?.trim();
        if (!token) { log('No token available for notification client (token input empty). Skipping direct notif client.'); return; }

        try {
            notifClient = new StompJs.Client({
                webSocketFactory: () => new SockJS(`${SERVER_WS_BASE}/ws`),
                connectHeaders: { Authorization: 'Bearer ' + token },
                debug: (str) => log('[notifClient] ' + str),
                reconnectDelay: 5000,
                onConnect: () => {
                    log(`notifClient connected, subscribing to ${fullNotifDestination}`);
                    try {
                        notifSubscription = notifClient.subscribe('/user/queue/notifications', (message) => {
                            log(`Notification(received via notifClient): ${message.body}`);
                            try {
                                const payload = JSON.parse(message.body);
                                const wrapper = document.createElement('div');
                                const strong = document.createElement('strong');
                                strong.textContent = `[${new Date().toLocaleTimeString()}] ${payload.type || 'NOTI'}(direct):`;
                                const txt = document.createElement('span');
                                let msg = payload.message ?? message.body ?? '';
                                try { if (typeof msg === 'string' && /%[0-9A-Fa-f]{2}/.test(msg)) msg = decodeURIComponent(msg); } catch(e){}
                                txt.textContent = ' ' + msg;
                                wrapper.appendChild(strong);
                                wrapper.appendChild(txt);
                                notificationsDiv.appendChild(wrapper);
                                notificationsDiv.scrollTop = notificationsDiv.scrollHeight;
                            } catch(e) {
                                const p = document.createElement('p'); p.textContent = `[RAW] ${message.body}`; notificationsDiv.appendChild(p); notificationsDiv.scrollTop = notificationsDiv.scrollHeight;
                            }
                        });
                    } catch (err) { log('notifClient subscribe error: ' + err); }
                },
                onStompError: (frame) => { log('[notifClient] STOMP error: ' + (frame && frame.headers ? frame.headers['message'] : frame)); log(frame && frame.body); },
                onWebSocketError: (err) => { log('[notifClient] WS error: ' + err); }
            });
            notifClient.activate();
        } catch (err) {
            log('Failed to create notifClient: ' + err);
        }
    }

    function unsubscribeNotifications() {
        try {
            if (notificationSubscription) { notificationSubscription.unsubscribe(); notificationSubscription = null; log('Unsubscribed main client notifications'); }
            if (notifSubscription) { notifSubscription.unsubscribe(); notifSubscription = null; log('Unsubscribed notifClient notifications'); }
            if (notifClient) { try { notifClient.deactivate(); } catch(e){} notifClient = null; }
        } catch (err) { log('Error during unsubscribeNotifications: ' + err); }
    }
</script>
</body>
</html>
