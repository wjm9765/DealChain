<!DOCTYPE html>
<html>
<head>
    <title>WebSocket STOMP Test</title>
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
</head>
<body>
<h1>WebSocket STOMP Test</h1>
<div>
    <label for="tokenInput">JWT Token:</label>
    <input type="text" id="tokenInput" placeholder="Enter JWT token here" style="width:400px;" />
    <button onclick="connect()">Connect</button>
    <!-- Disconnect 버튼은 자동 퇴장 후 disconnect하도록 요구되어 제거 -->
</div>
<div>
    <label for="roomIdInput">Room ID:</label>
    <input type="text" id="roomIdInput" value="4b504d2c-565c-4640-937c-fe9732510ca5" />
    <button onclick="subscribeToRoom()">Subscribe</button>
    <button onclick="unsubscribeFromRoom()">Unsubscribe</button>
</div>
<!-- 새로 추가: 개인 알림(Private Notifications) 구독 UI -->
<div style="margin-top:8px;">
    <button onclick="subscribeNotifications()">Subscribe Notifications</button>
    <button onclick="unsubscribeNotifications()">Unsubscribe Notifications</button>
</div>
<div>
    <label for="senderIdInput">Sender ID:</label>
    <input type="text" id="senderIdInput" value="10" />
    <br />
    <label for="messageInput">Message:</label>
    <input type="text" id="messageInput" placeholder="Enter message here" />
    <button onclick="sendMessage()">Send Message (TALK)</button>
    <button onclick="enterRoom()">Enter (ENTER)</button>
    <button onclick="leaveRoom()">Leave (LEAVE & Disconnect)</button>
</div>
<h2>Received Messages:</h2>
<div id="messages" style="border: 1px solid #ccc; height: 300px; overflow-y: scroll; padding: 10px;"></div>

<!-- 새로 추가: 개인 알림 표시 영역 (채팅 메시지와 분리) -->
<h2>Personal Notifications:</h2>
<div id="notifications" style="border: 1px solid #f39c12; height: 150px; overflow-y: auto; padding: 10px; background:#fff8e1;"></div>

<script>
    let stompClient = null;
    let currentSubscription = null;
    // 새로 추가: 개인 알림 구독 핸들
    let notificationSubscription = null;
    const messagesDiv = document.getElementById('messages');
    const notificationsDiv = document.getElementById('notifications');

    function log(message) {
        console.log(message);
        const p = document.createElement('p');
        p.textContent = `[LOG] ${message}`;
        messagesDiv.appendChild(p);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function connect() {
        if (stompClient && stompClient.active) {
            log("Already connected.");
            return;
        }

        const token = document.getElementById('tokenInput').value?.trim();
        if (!token) {
            log('No token provided. Please enter JWT token before connecting.');
            return;
        }

        log("Attempting to connect...");

        // Prepare connect headers with Authorization
        const connectHeaders = {
            Authorization: 'Bearer ' + token
        };

        stompClient = new StompJs.Client({
            // SockJS 사용 설정
            webSocketFactory: () => new SockJS('http://localhost:8080/ws'), // 서버 주소 확인!
            connectHeaders: connectHeaders,
            debug: function (str) { log("STOMP Debug: " + str); },
            reconnectDelay: 5000,
            heartbeatIncoming: 4000,
            heartbeatOutgoing: 4000,
            onConnect: (frame) => {
                log('Connected: ' + frame);
                // 연결 성공 시 UI 업데이트 (예: 버튼 활성화)
            },
            onStompError: (frame) => {
                log('Broker reported error: ' + frame.headers['message']);
                log('Additional details: ' + frame.body);
            },
            onWebSocketError: (error) => {
                log('WebSocket Error: ' + error);
            },
             onDisconnect: () => {
                 log('Disconnected');
                 stompClient = null; // 클라이언트 객체 초기화
                 currentSubscription = null; // 구독 정보 초기화
                 // 개인 알림 구독도 초기화
                 if (notificationSubscription) notificationSubscription = null;
             }
        });

        stompClient.activate(); // 연결 시작
    }

    function disconnect() {
        if (stompClient && stompClient.active) {
            stompClient.deactivate(); // 연결 종료
        } else {
            log("Not connected.");
        }
    }

    function subscribeToRoom() {
        if (!stompClient || !stompClient.active) {
            log("Connect first!");
            return;
        }
        if (currentSubscription) {
            log("Already subscribed. Unsubscribe first if you want to change the room.");
            return;
        }

        const roomId = document.getElementById('roomIdInput').value;
        if (!roomId) {
            log("Enter Room ID!");
            return;
        }
        const destination = `/sub/chat/room/${roomId}`;

        log(`Attempting to subscribe to ${destination}`);
        try {
            // 구독 시작 및 구독 객체 저장
            currentSubscription = stompClient.subscribe(destination, (message) => {
                log(`Received message: ${message.body}`);
                try {
                    const msgData = JSON.parse(message.body);
                    const p = document.createElement('p');
                    p.innerHTML = `<strong>${msgData.senderId || 'System'}:</strong> ${msgData.message}`;
                    messagesDiv.appendChild(p);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                } catch(e) {
                     log(`Error parsing message: ${e}`);
                }
            });
            log(`Subscribed to ${destination} with ID: ${currentSubscription.id}`);
        } catch (error) {
            log(`Subscription error: ${error}`);
        }
    }

     function unsubscribeFromRoom() {
         if (!currentSubscription) {
             log("Not currently subscribed to any room.");
             return;
         }
         try {
             currentSubscription.unsubscribe(); // 구독 해제
             log(`Unsubscribed from ID: ${currentSubscription.id}`);
             currentSubscription = null; // 구독 정보 초기화
         } catch (error) {
             log(`Unsubscription error: ${error}`);
         }
     }

    function sendMessage() {
        if (!stompClient || !stompClient.active) {
            log("Connect first!");
            return;
        }
        if (!currentSubscription) {
            log("Subscribe to a room first!");
            return;
        }

        const roomId = document.getElementById('roomIdInput').value;
        const senderId = Number(document.getElementById('senderIdInput').value);
        const messageContent = document.getElementById('messageInput').value;

        if (Number.isNaN(senderId) || !messageContent.trim()) {
            log("Enter Sender ID and Message!");
            return;
        }

        const messageToSend = {
            type: "TALK",
            roomId: roomId,
            senderId: senderId,
            message: messageContent
        };

        const destination = "/pub/chat/message"; // 메시지 발행 목적지

        try {
            stompClient.publish({
                destination: destination,
                body: JSON.stringify(messageToSend)
            });
            log(`Message sent to ${destination}: ${JSON.stringify(messageToSend)}`);
            document.getElementById('messageInput').value = ''; // 입력 필드 비우기
        } catch (error) {
            log(`Send error: ${error}`);
        }
    }

    // 새로 추가: 입장 메시지 발송 (ENTER)
    function enterRoom() {
        if (!stompClient || !stompClient.active) {
            log("Connect first!");
            return;
        }
        const roomId = document.getElementById('roomIdInput').value;
        const senderId = Number(document.getElementById('senderIdInput').value);
        if (!roomId || Number.isNaN(senderId)) {
            log("Enter Room ID and Sender ID before entering.");
            return;
        }
        const messageToSend = {
            type: "ENTER",
            roomId: roomId,
            senderId: senderId,
            message: `${senderId}님이 입장합니다.`
        };
        const destination = "/pub/chat/message";
        try {
            stompClient.publish({ destination: destination, body: JSON.stringify(messageToSend) });
            log(`ENTER sent: ${JSON.stringify(messageToSend)}`);
        } catch (error) {
            log(`ENTER send error: ${error}`);
        }
    }

    // 새로 추가: 퇴장 메시지 발송 후 자동 disconnect
    function leaveRoom() {
        if (!stompClient || !stompClient.active) {
            log("Connect first!");
            return;
        }
        const roomId = document.getElementById('roomIdInput').value;
        const senderId = Number(document.getElementById('senderIdInput').value);
        if (!roomId || Number.isNaN(senderId)) {
            log("Enter Room ID and Sender ID before leaving.");
            return;
        }
        const messageToSend = {
            type: "LEAVE",
            roomId: roomId,
            senderId: senderId,
            message: `${senderId}님이 퇴장합니다.`
        };
        const destination = "/pub/chat/message";
        try {
            stompClient.publish({ destination: destination, body: JSON.stringify(messageToSend) });
            log(`LEAVE sent: ${JSON.stringify(messageToSend)}. Will disconnect shortly.`);
            // LEAVE 전송 후 서버에 메시지가 전달될 시간을 잠시 준 뒤 연결 종료
            setTimeout(() => {
                try {
                    disconnect();
                } catch (e) {
                    log('Error during disconnect: ' + e);
                }
            }, 200);
        } catch (error) {
            log(`LEAVE send error: ${error}`);
        }
    }

    // 새로 추가: 개인 알림 구독 함수
    function subscribeNotifications() {
        if (!stompClient || !stompClient.active) {
            log("Connect first!");
            return;
        }
        if (notificationSubscription) {
            log("Already subscribed to personal notifications.");
            return;
        }
        try {
            // '/user/queue/notifications' 경로 구독
            notificationSubscription = stompClient.subscribe('/user/queue/notifications', (message) => {
                log(`Notification received: ${message.body}`);
                try {
                    const payload = JSON.parse(message.body);
                    // 간단한 표시: 시간 + 타입 + 메시지
                    const p = document.createElement('p');
                    const when = new Date().toLocaleTimeString();
                    p.innerHTML = `<strong>[${when}] ${payload.type || 'NOTI'}</strong>: ${payload.message || message.body}`;
                    notificationsDiv.appendChild(p);
                    notificationsDiv.scrollTop = notificationsDiv.scrollHeight;
                } catch (e) {
                    // JSON parsing 실패 시 원문 출력
                    const p = document.createElement('p');
                    p.textContent = `[RAW] ${message.body}`;
                    notificationsDiv.appendChild(p);
                    notificationsDiv.scrollTop = notificationsDiv.scrollHeight;
                }
            });
            log('Subscribed to /user/queue/notifications');
        } catch (error) {
            log(`Notification subscription error: ${error}`);
        }
    }

    function unsubscribeNotifications() {
        if (!notificationSubscription) {
            log('Not subscribed to personal notifications.');
            return;
        }
        try {
            notificationSubscription.unsubscribe();
            log('Unsubscribed from personal notifications.');
            notificationSubscription = null;
        } catch (error) {
            log(`Notification unsubscription error: ${error}`);
        }
    }
</script>
</body>
</html>